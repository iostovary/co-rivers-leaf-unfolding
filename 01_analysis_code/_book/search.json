[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Co-Drivers beyond temperature shape the timing of leaf unfolding in temperate trees",
    "section": "",
    "text": "Readme\nThis readme gives an overview over the scripts and steps for generating the outputs and analyses associated with this manuscript.",
    "crumbs": [
      "Preface",
      "Readme"
    ]
  },
  {
    "objectID": "index.html#platforms",
    "href": "index.html#platforms",
    "title": "Co-Drivers beyond temperature shape the timing of leaf unfolding in temperate trees",
    "section": "Platforms",
    "text": "Platforms\nOperating systems and software used for development and implementation\n\nWindows 11 Education (V 23H2)\nR version 4.3.2 (2023-10-31 ucrt)",
    "crumbs": [
      "Preface",
      "Readme"
    ]
  },
  {
    "objectID": "index.html#directory-overview",
    "href": "index.html#directory-overview",
    "title": "Co-Drivers beyond temperature shape the timing of leaf unfolding in temperate trees",
    "section": "Directory overview",
    "text": "Directory overview\n\n00_helpers/: Helper functions for calling standard libraries, plot themes and formatting.\n01_analysis_code/: Code for running the analysis. Code for data processing was not included because tree coordinates cannot be disclosed to protect the privacy of citizen scientists.\n01_analysis_code/_book: Rendered report of the analysis with all results.\nown_data/: Input data to run the analysis.\nown_data/output_data: Output data generated by the analysis.",
    "crumbs": [
      "Preface",
      "Readme"
    ]
  },
  {
    "objectID": "index.html#scripts",
    "href": "index.html#scripts",
    "title": "Co-Drivers beyond temperature shape the timing of leaf unfolding in temperate trees",
    "section": "Scripts",
    "text": "Scripts\n\n4_euler_dredge_all.R: Script for parallelized generation of model variations and evaluation of model weights\n4_intro_global_models.qmd: Script to generate reference models and dependent scripts (e.g. species specific reports)\n5_manual_SPECIES_SHORT_leaf_unfolding.R: Script to generate manually specified improved reference models. Do not run this script, the main script will run it automatically.\n5_results_SPECIES_SHORT_leaf_unfolding.qmd: Processing of model outputs.\n6_species_comparison_leaf_unfolding.qmd: Results.",
    "crumbs": [
      "Preface",
      "Readme"
    ]
  },
  {
    "objectID": "index.html#how-to-run-the-code",
    "href": "index.html#how-to-run-the-code",
    "title": "Co-Drivers beyond temperature shape the timing of leaf unfolding in temperate trees",
    "section": "How to run the code",
    "text": "How to run the code\n\nInstall quarto for R Studio\nOpen the project file with R Studio and enter “quarto render” and the folder path into the terminal.\nR-packages will be installed automatically if they are not yet installed on your machine. Rendering the report will generate all required dependent scripts, data and results. The report will be generated in the folder _book/. All subfolders within _book contain the figures relevant to the publication. It will take at least 3 h per species to generate the model variations, if you want to reproduce them yourself instead of using the provided files. The typical runtime for rendering the report is approximately 5-10 minutes.",
    "crumbs": [
      "Preface",
      "Readme"
    ]
  },
  {
    "objectID": "4_intro_global_models.html",
    "href": "4_intro_global_models.html",
    "title": "1  Models",
    "section": "",
    "text": "1.1 Technical implementation\nRandom effects as well as autoregressive parameters for all models and complex fixed effects for the global models were stored in objects and supplied to the different models.",
    "crumbs": [
      "Methods",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Models</span>"
    ]
  },
  {
    "objectID": "4_intro_global_models.html#technical-implementation",
    "href": "4_intro_global_models.html#technical-implementation",
    "title": "1  Models",
    "section": "",
    "text": "1.1.1 Universal random effects\nIn all models the grouping variable METEO_ID was used. Nested groupings to account for different observers were not possible due to insufficient observer levels within the same time series.\n\n\n\nShow the code\n\nRandom effect.\n\nrandom_simple &lt;- as.formula(~ 1 | METEO_ID)\nsaveRDS(random_simple, paste0(path_output_data, \"/random_simple.rds\"))\n\n\n\n\n\n1.1.2 Universal autoregressive parameter\nAn autoregressive parameter was used to account for the temporal autocorrelation in the residuals. The parameter was estimated for each METEO_ID.\n\n\n\nShow the code\n\nAutoregressive parameter.\n\nautoregression_simple &lt;- corAR1(form = ~ year | METEO_ID)\nsaveRDS(autoregression_simple, paste0(path_output_data, \"/autoregression_simple.rds\"))",
    "crumbs": [
      "Methods",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Models</span>"
    ]
  },
  {
    "objectID": "4_intro_global_models.html#reference-models",
    "href": "4_intro_global_models.html#reference-models",
    "title": "1  Models",
    "section": "1.2 Reference models",
    "text": "1.2 Reference models\nThe traditional reference models contain only a linear warming term. They represent the typical approach to analyse phenological data. I then tested whether the temperature terms are in fact linear, polynomial or whether both terms are required. Consequently the refined reference models contain a linear and a quadratic warming term with or without a cooling term. They serve as a contrast for additional parameters such as tree height or stand height.\n\n\nShow the code\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    data &lt;- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %&gt;%\n      rename_fun() %&gt;%\n      select(-LEAF_COLOURING_LAG) %&gt;%\n      filter(complete.cases(.)) %&gt;%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    random_simple &lt;- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n    autoregression_simple &lt;- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n    \n    models &lt;- list(\n      ref_true_mai_int = tryCatch(\n        lme(fixed = doy ~ GDD_mainstream, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_true_con_int = tryCatch(\n        lme(fixed = doy ~ GDD_conservative, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_true_mai_slo = tryCatch(\n        lme(fixed = doy ~ GDD_mainstream,\n            random = ~ 1 + GDD_mainstream | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n\n      ref_true_con_slo = tryCatch(\n        lme(fixed = doy ~ GDD_conservative,\n            random = ~ 1 + GDD_conservative | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL)\n      )\n   \n      if (!is.null(models)) {\n        saveRDS(models, paste0(path_output_data, \"/ref_true\", \"_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      } else {\n        message(\"Something for \", species, \" \", phase, \" failed.\")\n      }\n    }\n  }\n\n\n\n\nShow the code\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    data &lt;- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %&gt;%\n      rename_fun() %&gt;%\n      select(-LEAF_COLOURING_LAG) %&gt;%\n      filter(complete.cases(.)) %&gt;%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    models &lt;- list(\n      temp_test_mai_int = tryCatch(\n        lme(fixed = doy ~ poly(GDD_mainstream, degree = 2), \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      temp_test_mai_slo = tryCatch(\n        lme(fixed = doy ~ poly(GDD_mainstream, degree = 2), \n            random = ~ 1 + GDD_mainstream | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      temp_test_con_int = tryCatch(\n        lme(fixed = doy ~ poly(GDD_conservative, degree = 2), \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      temp_test_con_slo = tryCatch(\n        lme(fixed = doy ~ poly(GDD_conservative, degree = 2), \n            random = ~ 1 + GDD_conservative | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL)\n      )\n   \n      if (!is.null(models)) {\n        saveRDS(models, paste0(path_output_data, \"/temp_test\", \"_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      } else {\n        message(\"Something for \", species, \" \", phase, \" failed.\")\n      }\n    }\n  }\n\n\n\n\nShow the code\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    data &lt;- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %&gt;%\n      rename_fun() %&gt;%\n      select(-LEAF_COLOURING_LAG) %&gt;%\n      filter(complete.cases(.)) %&gt;%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    random_simple &lt;- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n    autoregression_simple &lt;- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n    \n    # create refined reference models\n    models &lt;- list(\n      ref_imp_mai_int_poly = tryCatch(\n        lme(fixed = doy ~ poly(GDD_mainstream, degree=2) * CDD_mainstream, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_imp_mai_int_line = tryCatch(\n        lme(fixed = doy ~ GDD_mainstream * CDD_mainstream, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_imp_con_int_poly = tryCatch(\n        lme(fixed = doy ~ poly(GDD_conservative, degree=2) * CDD_conservative, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_imp_con_int_line = tryCatch(\n        lme(fixed = doy ~ GDD_conservative * CDD_conservative, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL)\n    )\n   \n    for (model_name in names(models)) {\n      model &lt;- models[[model_name]]\n      \n      if (!is.null(model)) {\n        selected_subset &lt;- NULL\n\n        dredge_result &lt;- dredge(model, \n                                  # extra = list(\"RMSE\" = function(x) sqrt(mean(residuals(x)^2))),\n                                  rank = list(cAIC = fun_get_caic),\n                                  fixed = c(\"poly(GDD_mainstream, degree = 2)\", \"GDD_mainstream\", \"poly(GDD_conservative, degree = 2)\", \"GDD_conservative\")\n                                  )\n          \n          ref &lt;- get.models(dredge_result, subset = TRUE, method = \"ML\") %&gt;% setNames(paste0(model_name, \"_\", seq_along(.)))\n\n          \n          saveRDS(ref, paste0(path_output_data, \"/\",\n                              model_name, \"_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n        } else {\n        message(\"Model \", model_name, \" for \", species, \" \", phase, \" failed.\")\n      }\n    }\n  }\n}",
    "crumbs": [
      "Methods",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Models</span>"
    ]
  },
  {
    "objectID": "4_intro_global_models.html#global-models",
    "href": "4_intro_global_models.html#global-models",
    "title": "1  Models",
    "section": "1.3 Global models",
    "text": "1.3 Global models\nBased on the hypothesis that the adjusted effects of temperature, drought, stand structure, soil characteristics and topography influence the timing of leaf unfolding two global models (mainstream and conservative) were developed. The method for calculating the temperature sums can impact the results considerably. Consequently the global model “mainstream” uses GDD and CDD sums according to the common approach to end accumulation at the mean doy per site, whereas the global model”conservative” uses GDD and CDD sums that were ended at the earliest 5% percentile of doys per site.\n\n1.3.0.1 Fixed mainstream effects\n\n\n\nShow the code\n\nLoop to generate all mainstream fixed effects for all species.\n\nfor (phase in phase_list) {\n  for (species in species_list) {\n    if (phase == \"leaf unfolding\") {\n      if (species == \"FS\") { # global model for evergreens\n        fixed_effects &lt;- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"LD\") {\n        fixed_effects &lt;- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"PA\") {\n        fixed_effects &lt;- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"TC\"){\n        fixed_effects &lt;- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n        }\n      }\n    \n    else { # global model for other phase\n      fixed_effects &lt;- as.formula(doy ~ other)\n    }\n    \n    saveRDS(fixed_effects, paste0(path_output_data, \"/fixed_mainstream_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n  }\n}\n\n\n\n\n\n1.3.0.2 Fixed conservative effects\n\n\n\nShow the code\n\nLoop to generate all conservative fixed effects for all species.\n\nfor (phase in phase_list) {\n  for (species in species_list) {\n    if (phase == \"leaf unfolding\") {\n      if (species == \"FS\") { # global model for evergreens\n        fixed_effects &lt;- as.formula(doy ~\n          poly(GDD_conservative, degree=2) * CDD_conservative +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"LD\") {\n        fixed_effects &lt;- as.formula(doy ~\n          poly(GDD_conservative, degree=2) * CDD_conservative +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"PA\") {\n        fixed_effects &lt;- as.formula(doy ~\n          poly(GDD_conservative, degree=2) +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"TC\"){\n        fixed_effects &lt;- as.formula(doy ~\n          GDD_conservative * CDD_conservative +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n        }\n      }\n    \n    else { # global model for other phase\n      fixed_effects &lt;- as.formula(doy ~ other)\n    }\n    \n    saveRDS(fixed_effects, paste0(path_output_data, \"/fixed_conservative_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n  }\n}\n\n\n\n\n\n1.3.0.3 Global model combinations\n\n\n\nShow the code\n\nLoop to generate all global models for all species.\n\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    # load data\n    data &lt;- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %&gt;%\n      rename_fun() %&gt;%\n      select(-LEAF_COLOURING_LAG) %&gt;%\n      filter(complete.cases(.)) %&gt;%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    # load fixed effects\n    fixed_conservative &lt;- readRDS(paste0(path_output_data, \"/fixed_conservative_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n    fixed_mainstream &lt;- readRDS(paste0(path_output_data, \"/fixed_mainstream_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n    \n    # load random effects  \n    random_simple &lt;- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n    \n    # load autoregression parameter\n    autoregression_simple &lt;- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n\n    # mainstream\n      # random simple\n      tryCatch({\n      global_maisim  &lt;- eval(bquote(lme(fixed = fixed_mainstream, random = random_simple, data = data, method = \"ML\", correlation = autoregression_simple)))\n      saveRDS(global_maisim, paste0(path_output_data, \"/global_mai_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      }, error = function(e) message(\"Error in model with global_maisim for \", species, \" \", phase, \": \", e$message))\n\n    # conservative\n      # random simple\n      tryCatch({\n      global_consim &lt;- eval(bquote(lme(fixed = fixed_conservative, random = random_simple, data = data, method = \"ML\", correlation = autoregression_simple)))\n      saveRDS(global_consim, paste0(path_output_data, \"/global_con_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      }, error = function(e) message(\"Error in model with global_consim for \", species, \" \", phase, \": \", e$message))\n  }\n}\n\n\n\n\n\n1.3.1 Generation of global model variations\nThe variations of all global models were created with mumln::dredge. The function was fitted with each global model and set to test all combinations that contained a growing degree day term and ≤ 10 terms in total.\n\n\n\nShow the code\n\nExecution of mumln:dredge via an array for all global models.\n\n### Setup ###\n\nlocation &lt;- \"large_models/\"\nsublocation &lt;- \"input_unscaled_squared_in_model/\"\ndata_subset &lt;- \"unscaled_\"\n\nlibrary(nlme) # linear mixed-effects models\nlibrary(MuMIn) # automated model selection\nlibrary(data.table)\nlibrary(tidyverse) # data manipulation\nlibrary(cAIC4) # conditional Akaike Information Criterion\n\n# load standard libraries\nsource(paste0(location,\"00_helpers/rename_fun.R\"))\n\n# load random effects and autoregression parameter\nrandom_simple &lt;- readRDS(paste0(location, \"own_data/output_data/random_simple.rds\"))\nautoregression_simple &lt;- readRDS(paste0(location, \"own_data/output_data/autoregression_simple.rds\"))\n\n# function to extract cAIC and return NA if failed\nfun_get_caic &lt;- function(x) {\n  tryCatch({\n    cAIC(x)$caic # accessing the specific value from the cAIC function\n  }, error = function(e) {\n    NA # return NA or some indication of failure for models that cause an error\n  })\n}\n\n# create array ####\n# array for parallelized computing (not required if run on a single machine)\nif (!(Sys.getenv(\"SLURM_ARRAY_TASK_ID\") == \"\")) {\n  i &lt;- as.numeric(Sys.getenv(\"SLURM_ARRAY_TASK_ID\"))\n}\n\ntable &lt;- expand.grid(\n  species = c(\"FS\", \"LD\", \"PA\", \"TC\"),\n  phase = \"leaf_unfolding\",\n  model = c(\"mai\", \"con\"),\n  stringsAsFactors = FALSE) %&gt;%\n  mutate(ID = row_number()) %&gt;%\n  relocate(ID)\n\nspecies_ID &lt;- table[i, \"species\"]\nphase_ID &lt;- table[i, \"phase\"]\nmodel_ID &lt;- table[i, \"model\"]\n\n# load species specific data ####\ndata &lt;- readRDS(paste0(location, \"own_data/output_data/data_\", data_subset , species_ID, \"_\", phase_ID, \".rds\")) %&gt;%\n  rename_fun() %&gt;%\n  select(-LEAF_COLOURING_LAG) %&gt;%\n  # make sure data types are set correctly\n  mutate(METEO_ID = factor(METEO_ID),\n         RELIEF = factor(RELIEF),\n         SOCIAL_SITUATION = factor(SOCIAL_SITUATION),\n         EDGE_DIST_IMPUTED = factor(EDGE_DIST_IMPUTED)) # somehow cAIC is really bad with handling factors and it's best to make them explicit, even if R has recognized them correctly when reading the data set\n\n# load fixed effects\nfixed_mainstream &lt;- readRDS(paste0(location, \"own_data/output_data/\",\n                                   \"fixed_mainstream_\", species_ID, \"_\", gsub(\" \", \"_\", phase_ID), \".rds\"))\nfixed_conservative &lt;- readRDS(paste0(location, \"own_data/output_data/\",\n                                     \"fixed_conservative_\", species_ID, \"_\", gsub(\" \", \"_\", phase_ID), \".rds\"))\n\n# load model\nmodel &lt;- readRDS(paste0(location, \"own_data/output_data/\",\n                        \"global_\", model_ID, \"_\", species_ID, \"_\", phase_ID, \".rds\"))\n\n# dredge ####\ndredge_result &lt;- dredge(model, extra = list(\"RMSE\" = function(x) {sqrt(mean(residuals(x)^2))}),\n                        rank = list(cAIC = fun_get_caic),\n                        m.lim = c(1, 10),\n                        fixed = c(\"poly(GDD_mainstream, degree = 2)\", \"GDD_mainstream\", \"poly(GDD_conservative, degree = 2)\", \"GDD_conservative\")\n                        )\n\n# remove failed models from the results\ndredge_result_clean &lt;- subset(dredge_result, subset = !is.na(cAIC))\n\n# subset delta 4 and recalculate weights\ndredge_result_d4 &lt;- subset(dredge_result_clean, subset = delta &lt; 4)\nWeights(dredge_result_d4$cAIC)\n\n# subset delta 2 and recalculate weights\ndredge_result_d2 &lt;- subset(dredge_result_clean, subset = delta &lt; 2)\nWeights(dredge_result_d2$cAIC)\n\n# remove large object for faster processing\nrm(dredge_result_clean)\n\n# get most parsimonious models\nparsimonious_d4 &lt;- get.models(dredge_result_d4, subset = order(dredge_result_d4$df)[1:3], method = \"ML\")\nparsimonious_d2 &lt;- get.models(dredge_result_d2, subset = order(dredge_result_d2$df)[1:3], method = \"ML\")\n\n# extract weights\nsummary_weight_d4 &lt;- sw(dredge_result_d4) %&gt;% as.data.frame() %&gt;% rownames_to_column(\"PARAMETER\") %&gt;% rename(WEIGHT=2) %&gt;% mutate(MODEL= model_ID)\nsummary_weight_d2 &lt;- sw(dredge_result_d2) %&gt;% as.data.frame() %&gt;% rownames_to_column(\"PARAMETER\") %&gt;% rename(WEIGHT=2) %&gt;% mutate(MODEL= model_ID)\n\n# save three best models\nbest_names &lt;- c(paste0(\"best_\", model_ID, \"_1\"),\n                paste0(\"best_\", model_ID, \"_2\"),\n                paste0(\"best_\", model_ID, \"_3\"))\nbest &lt;- get.models(dredge_result_d2, subset = order(cAIC)[1:3], method = \"ML\") %&gt;% setNames(best_names)\nsaveRDS(best, paste0(location, \"own_data/output_data/\", #sublocation,\n                     \"best_\", model_ID, \"_\", species_ID, \"_\", gsub(\" \", \"_\", phase_ID), \".rds\"))\n\n# save result ####\nsaveRDS(list(\n  model_name = model_ID,\n  dredge_result = dredge_result,\n  dredge_result_d4 = dredge_result_d4,\n  dredge_result_d2 = dredge_result_d2,\n  parsimonious_d4 = parsimonious_d4,\n  parsimonious_d2 = parsimonious_d2,\n  summary_weight_d4 = summary_weight_d4,\n  summary_weight_d2 = summary_weight_d2\n),\npaste0(location,\"own_data/output_data/\", # sublocation,\n       \"dredge_\", model_ID, \"_\", species_ID, \"_\", phase_ID, \".rds\"))\n\n\n\nParameter weights were calculated for all models with delta cAIC &lt; 4 and &lt; 2 [@burnham2002] for further consideration and the three models with the lowest cAIC (best models) and the models with the least number of parameters (parsimonious models) were extracted for further analysis.\n\n\n1.3.2 Limitations\nWe wanted to adjust the social situation with an interaction with edge distance. However, this led to issues with the covariance matrix. Edge-distance was removed, because it has little validity as a main effect. Furthermore, it would have been useful to test the global model with a warming term in interaction with all other terms. However, this is computationally expensive. Therefore, only the most important interactions were kept. Due to a substantial amount of missing values for leaf colouring containing it was removed from the global models.",
    "crumbs": [
      "Methods",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Models</span>"
    ]
  },
  {
    "objectID": "4_intro_global_models.html#final-models",
    "href": "4_intro_global_models.html#final-models",
    "title": "1  Models",
    "section": "1.4 Final models",
    "text": "1.4 Final models\nThe final models were generated from the best and most parsimonious model variations of the global model. They demonstrate what the effects of important parameters could look like and how good they would be with prediction. If the quadratic term was significant, non-significant linear terms were kept. If only the linear term was significant, the quadratic term was discarded. Interactions were only kept where significant.",
    "crumbs": [
      "Methods",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Models</span>"
    ]
  },
  {
    "objectID": "4_intro_global_models.html#model-diagnostics",
    "href": "4_intro_global_models.html#model-diagnostics",
    "title": "1  Models",
    "section": "1.5 Model diagnostics",
    "text": "1.5 Model diagnostics\nCompliance with model assumptions was assessed with a residual analysis for each set of species specific models. Multicollinearity was assessed with the corvif function by @zuur2009. Cooks distance and leverage was assessed with HLMdiag::cooks.distance and HLMdiag::leverage because more common packages and functions were incompatible with nlme::lme-objects. Some models with temperature parametrized to the mean site leaf unfolding date (mainstream) had issues with residual distributions. Therefore only models with temperature parametrized to the \\(Q_{0.05}\\) site leaf unfolding date (conservative) were considered for the model selection.",
    "crumbs": [
      "Methods",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Models</span>"
    ]
  },
  {
    "objectID": "4_intro_global_models.html#model-selection",
    "href": "4_intro_global_models.html#model-selection",
    "title": "1  Models",
    "section": "1.6 Model selection",
    "text": "1.6 Model selection\nModels that met all diagnostic criteria were selected and compared using the cAIC and RMSE.",
    "crumbs": [
      "Methods",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Models</span>"
    ]
  },
  {
    "objectID": "5_results_FS_leaf_unfolding.html",
    "href": "5_results_FS_leaf_unfolding.html",
    "title": "2  Fagus sylvatica",
    "section": "",
    "text": "2.1 Effect shape of temperature\nTable 2.1: Comparison of model performance of linear and polynomial temperature parameters with cAIC and RMSE.\nTable 2.2: Comparison of parameters across models with estimate, standard error, t-value and p-value",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fagus sylvatica</span>"
    ]
  },
  {
    "objectID": "5_results_FS_leaf_unfolding.html#effect-shape-of-temperature-with-chilling",
    "href": "5_results_FS_leaf_unfolding.html#effect-shape-of-temperature-with-chilling",
    "title": "2  Fagus sylvatica",
    "section": "2.2 Effect shape of temperature with chilling",
    "text": "2.2 Effect shape of temperature with chilling\n\n\n\n\nTable 2.3: Comparison of model performance of linear and non-linear growing degree days in combination with chilling degree days.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 2.4: Comparison of siginificance of various growing and chilling degree day combinations.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fagus sylvatica</span>"
    ]
  },
  {
    "objectID": "5_results_FS_leaf_unfolding.html#global-model-variations",
    "href": "5_results_FS_leaf_unfolding.html#global-model-variations",
    "title": "2  Fagus sylvatica",
    "section": "2.3 Global model variations",
    "text": "2.3 Global model variations\n\n\n\n\nTable 2.5: Number of equally or almost equally informative conservative model variations and maximum model weights (Δ cAIC &lt; 4 and &lt; 2).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 2.6: The three best model variations derived from the global model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 2.7: The three most parsimonious models derived from the global model.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fagus sylvatica</span>"
    ]
  },
  {
    "objectID": "5_results_FS_leaf_unfolding.html#model-processing",
    "href": "5_results_FS_leaf_unfolding.html#model-processing",
    "title": "2  Fagus sylvatica",
    "section": "2.4 Model processing",
    "text": "2.4 Model processing\n\n\nShow the code\n# nest data set\nmanual_models_input &lt;- data %&gt;%\n  nest()\n\n# save to file for evaluation of manual models in the template\nsaveRDS(manual_models_input, paste0(path_output_data, \"/manual_models_\", species, \"_\", gsub (\" \", \"_\", phase), \".rds\"))\n\n# source manual models to be evaluated within template\nsource(paste0(location, \"/5_manual_\", species, \"_\", gsub (\" \", \"_\", phase), \".R\"), echo=TRUE, max.deparse.length = 5000)\n\n\n\n&gt; manual_models &lt;- manual_models_input %&gt;% mutate(final_con_int = map(data, \n+     safely(~lme(fixed = doy ~ poly(GDD_conservative, degree = 2) * \n+         CDD_conservative + poly(TREE_HEIGHT, degree = 2) + TREE_ELEVATION, \n+         random = ~1 | METEO_ID, data = ., method = \"ML\", correlation = autoregression_simple, \n+         na.action = na.omit))), ref_imp_con_int = map(data, safely(~lme(fixed = doy ~ \n+     GDD_conservative + CDD_conservative, random = ~1 | METEO_ID, \n+     data = ., method = \"ML\", correlation = autoregression_simple, \n+     na.action = na.omit))), final_con_slo = map(data, safely(~lme(fixed = doy ~ \n+     poly(GDD_conservative, degree = 2) * CDD_conservative + poly(TREE_HEIGHT, \n+         degree = 2) + TREE_ELEVATION, random = ~1 + poly(GDD_conservative, \n+     degree = 2)[, 1] | METEO_ID, data = ., method = \"ML\", correlation = autoregression_simple, \n+     na.action = na.omit, control = lmeControl(opt = \"optim\")))), \n+     ref_imp_con_slo = map(data, safely(~lme(fixed = doy ~ poly(GDD_conservative, \n+         degree = 2) * CDD_conservative, random = ~1 + poly(GDD_conservative, \n+         degree = 2)[, 1] | METEO_ID, data = ., method = \"ML\", \n+         correlation = autoregression_simple, na.action = na.omit, \n+         control = lmeControl(opt = \"optim\")))))\n\n\nShow the code\n# format manual models to fit the data frame structure\nmanual_models &lt;- manual_models %&gt;%\n  pivot_longer(cols = 2:ncol(.), names_to = \"model_name\", values_to = \"model\") %&gt;% \n  filter(map_lgl(model, ~ !is.null(.x$result))) %&gt;%\n  mutate(model = map(model, \"result\"))\n\n\n\n\nShow the code\n# function to extract coefficients with confidence intervals\nsafe_tidy &lt;- possibly(\n  ~ broom.mixed::tidy(.x, conf.int = TRUE) %&gt;% mutate(model_name = .y), \n  otherwise = NULL\n)\n\nmodels &lt;- bind_rows(manual_models, ref_imp_models, ref_true_models, temp_test_models, global_models, best_models, parsimonious_models\n                    ) %&gt;%\n  filter(!str_detect(model_name, exclude_type)) %&gt;% \n  mutate(tidy = map2(model, model_name, safe_tidy), # extract coefficients and p-values\n         augment = map2(model, model_name, ~{ # extract fitted values, residuals, fixed effects without data that is not contained in the respective model\n           terms &lt;- all.vars(formula(.x))[-1]  # Extract terms and remove response variable\n           broom.mixed::augment(.x) %&gt;%\n           select(all_of(terms), METEO_ID, year, SPECIES_SHORT, .fitted, .resid, .fixed) %&gt;%\n           mutate(model_name = .y)\n           }),\n         terms = map(model, ~all.vars(formula(.x))[-1]),\n         std_random = map(model, ~safely(~ {\n           intervals(.x)$reStruct %&gt;%\n             unlist() %&gt;%\n             as.data.frame() %&gt;%\n             rename(VALUE = 1) %&gt;%\n             rownames_to_column(\"PARAMETER\")})(.x)$result), # calculate and extract standard deviation of random effects\n         res_random = (res_random = map(model, ~.x$sigma)),\n         RMSE = map(model, ~sqrt(mean(.x$residuals^2))), # extract RMSE across populations\n         cAIC = map(model, ~fun_get_caic(.x)), # extract cAIC\n         logLik = map(model, ~fun_get_log(.x)) # extract logLik\n         ) %&gt;%\n  unnest(cAIC, logLik, RMSE) %&gt;% \n    mutate(coef = map(model, ~coef(.x)),\n           terms_count = map(model, ~length(fixef(.x))+1), # extract number of parameters and add 1 for the grouping variable (for more details see Pinheiro and Bates 2000, p. 8)\n           RMSE = as.numeric(RMSE),\n           delta_total_cAIC = cAIC - min(cAIC))\n\n\n\n\nShow the code\n# extract RMSE\nselection_parameters &lt;- models %&gt;% \n  select(-tidy, -augment, -data, -terms) %&gt;% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %&gt;% paste(collapse = \" \")) %&gt;% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %&gt;% paste(collapse = \" \")) %&gt;% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %&gt;% as.character()) %&gt;% # extract random effects\n  select(model_name, RMSE, cAIC, logLik, terms_count, calls, fixed_effects, random_effects) %&gt;%\n  unnest(RMSE, cAIC, logLik, terms_count) %&gt;%\n  # add family and type\n  mutate(type = case_when(str_detect(model_name, \"temp_test\") ~ \"effect shape\",\n                          str_detect(model_name, \"ref_true\") ~ \"traditional reference\",\n                          str_detect(model_name, \"ref_imp\") ~ \"refined reference\",\n                          str_detect(model_name, \"final\") ~ \"final model\",\n                          str_detect(model_name, \"best\") ~ \"best model\",\n                          str_detect(model_name, \"global\") ~ \"global model\",\n                          str_detect(model_name, \"pars\") ~ \"parsimonious model\",\n                          TRUE ~ \"other\"),\n         family = case_when(str_detect(model_name, \"con\") ~ \"conservative\",\n                            str_detect(model_name, \"mai\") ~ \"mainstream\",\n                            TRUE ~ \"other\")) %&gt;%\n  mutate(d.cAIC_absolute = cAIC - min(cAIC)) %&gt;% \n  group_by(family, type) %&gt;%\n  # add delta value per group\n  mutate(d.cAIC_group = cAIC - min(cAIC),\n         d.RMSE_group = RMSE - min(RMSE)) %&gt;% \n  ungroup()\n\n# extract coefficients and p-values\ntidy &lt;- models %&gt;% select(tidy) %&gt;% unnest(tidy)\n\n# extract fitted, fixed and residuals\naugment &lt;- models %&gt;% select(augment) %&gt;% unnest(augment)\n\n# extract standard deviation of random effects\nstd_random &lt;- models %&gt;% select(model_name, std_random) %&gt;% unnest(std_random) %&gt;% pivot_wider(names_from = PARAMETER, values_from = VALUE)\n\nres_random &lt;- models %&gt;% select(model_name, res_random) %&gt;% mutate(res_random = as.numeric(res_random))",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fagus sylvatica</span>"
    ]
  },
  {
    "objectID": "5_results_LD_leaf_unfolding.html",
    "href": "5_results_LD_leaf_unfolding.html",
    "title": "3  Larix decidua",
    "section": "",
    "text": "3.1 Effect shape of temperature\nTable 3.1: Comparison of model performance of linear and polynomial temperature parameters with cAIC and RMSE.\nTable 3.2: Comparison of parameters across models with estimate, standard error, t-value and p-value",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Larix decidua</span>"
    ]
  },
  {
    "objectID": "5_results_LD_leaf_unfolding.html#effect-shape-of-temperature-with-chilling",
    "href": "5_results_LD_leaf_unfolding.html#effect-shape-of-temperature-with-chilling",
    "title": "3  Larix decidua",
    "section": "3.2 Effect shape of temperature with chilling",
    "text": "3.2 Effect shape of temperature with chilling\n\n\n\n\nTable 3.3: Comparison of model performance of linear and non-linear growing degree days in combination with chilling degree days.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 3.4: Comparison of siginificance of various growing and chilling degree day combinations.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Larix decidua</span>"
    ]
  },
  {
    "objectID": "5_results_LD_leaf_unfolding.html#global-model-variations",
    "href": "5_results_LD_leaf_unfolding.html#global-model-variations",
    "title": "3  Larix decidua",
    "section": "3.3 Global model variations",
    "text": "3.3 Global model variations\n\n\n\n\nTable 3.5: Number of equally or almost equally informative conservative model variations and maximum model weights (Δ cAIC &lt; 4 and &lt; 2).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 3.6: The three best model variations derived from the global model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 3.7: The three most parsimonious models derived from the global model.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Larix decidua</span>"
    ]
  },
  {
    "objectID": "5_results_LD_leaf_unfolding.html#model-processing",
    "href": "5_results_LD_leaf_unfolding.html#model-processing",
    "title": "3  Larix decidua",
    "section": "3.4 Model processing",
    "text": "3.4 Model processing\n\n\nShow the code\n# nest data set\nmanual_models_input &lt;- data %&gt;%\n  nest()\n\n# save to file for evaluation of manual models in the template\nsaveRDS(manual_models_input, paste0(path_output_data, \"/manual_models_\", species, \"_\", gsub (\" \", \"_\", phase), \".rds\"))\n\n# source manual models to be evaluated within template\nsource(paste0(location, \"/5_manual_\", species, \"_\", gsub (\" \", \"_\", phase), \".R\"), echo=TRUE, max.deparse.length = 5000)\n\n\n\n&gt; manual_models &lt;- manual_models_input %&gt;% mutate(final_con_int = map(data, \n+     safely(~lme(fixed = doy ~ GDD_conservative * CDD_conservative, \n+         random = ~1 | METEO_ID, data = ., method = \"ML\", correlation = autoregression_simple, \n+         na.action = na.omit))), ref_imp_con_int = map(data, safely(~lme(fixed = doy ~ \n+     poly(GDD_conservative, degree = 2) + CDD_conservative, random = ~1 | \n+     METEO_ID, data = ., method = \"ML\", correlation = autoregression_simple, \n+     na.action = na.omit))), final_con_slo = map(data, safely(~lme(fixed = doy ~ \n+     poly(GDD_conservative, degree = 2) * CDD_conservative, random = ~1 + \n+     GDD_conservative | METEO_ID, data = ., method = \"ML\", correlation = autoregression_simple, \n+     na.action = na.omit))), ref_imp_con_slo = map(data, safely(~lme(fixed = doy ~ \n+     poly(GDD_conservative, degree = 2) * CDD_conservative, random = ~1 + \n+     GDD_conservative | METEO_ID, data = ., method = \"ML\", correlation = autoregression_simple, \n+     na.action = na.omit))))\n\n\nShow the code\n# format manual models to fit the data frame structure\nmanual_models &lt;- manual_models %&gt;%\n  pivot_longer(cols = 2:ncol(.), names_to = \"model_name\", values_to = \"model\") %&gt;% \n  filter(map_lgl(model, ~ !is.null(.x$result))) %&gt;%\n  mutate(model = map(model, \"result\"))\n\n\n\n\nShow the code\n# function to extract coefficients with confidence intervals\nsafe_tidy &lt;- possibly(\n  ~ broom.mixed::tidy(.x, conf.int = TRUE) %&gt;% mutate(model_name = .y), \n  otherwise = NULL\n)\n\nmodels &lt;- bind_rows(manual_models, ref_imp_models, ref_true_models, temp_test_models, global_models, best_models, parsimonious_models\n                    ) %&gt;%\n  filter(!str_detect(model_name, exclude_type)) %&gt;% \n  mutate(tidy = map2(model, model_name, safe_tidy), # extract coefficients and p-values\n         augment = map2(model, model_name, ~{ # extract fitted values, residuals, fixed effects without data that is not contained in the respective model\n           terms &lt;- all.vars(formula(.x))[-1]  # Extract terms and remove response variable\n           broom.mixed::augment(.x) %&gt;%\n           select(all_of(terms), METEO_ID, year, SPECIES_SHORT, .fitted, .resid, .fixed) %&gt;%\n           mutate(model_name = .y)\n           }),\n         terms = map(model, ~all.vars(formula(.x))[-1]),\n         std_random = map(model, ~safely(~ {\n           intervals(.x)$reStruct %&gt;%\n             unlist() %&gt;%\n             as.data.frame() %&gt;%\n             rename(VALUE = 1) %&gt;%\n             rownames_to_column(\"PARAMETER\")})(.x)$result), # calculate and extract standard deviation of random effects\n         res_random = (res_random = map(model, ~.x$sigma)),\n         RMSE = map(model, ~sqrt(mean(.x$residuals^2))), # extract RMSE across populations\n         cAIC = map(model, ~fun_get_caic(.x)), # extract cAIC\n         logLik = map(model, ~fun_get_log(.x)) # extract logLik\n         ) %&gt;%\n  unnest(cAIC, logLik, RMSE) %&gt;% \n    mutate(coef = map(model, ~coef(.x)),\n           terms_count = map(model, ~length(fixef(.x))+1), # extract number of parameters and add 1 for the grouping variable (for more details see Pinheiro and Bates 2000, p. 8)\n           RMSE = as.numeric(RMSE),\n           delta_total_cAIC = cAIC - min(cAIC))\n\n\n\n\nShow the code\n# extract RMSE\nselection_parameters &lt;- models %&gt;% \n  select(-tidy, -augment, -data, -terms) %&gt;% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %&gt;% paste(collapse = \" \")) %&gt;% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %&gt;% paste(collapse = \" \")) %&gt;% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %&gt;% as.character()) %&gt;% # extract random effects\n  select(model_name, RMSE, cAIC, logLik, terms_count, calls, fixed_effects, random_effects) %&gt;%\n  unnest(RMSE, cAIC, logLik, terms_count) %&gt;%\n  # add family and type\n  mutate(type = case_when(str_detect(model_name, \"temp_test\") ~ \"effect shape\",\n                          str_detect(model_name, \"ref_true\") ~ \"traditional reference\",\n                          str_detect(model_name, \"ref_imp\") ~ \"refined reference\",\n                          str_detect(model_name, \"final\") ~ \"final model\",\n                          str_detect(model_name, \"best\") ~ \"best model\",\n                          str_detect(model_name, \"global\") ~ \"global model\",\n                          str_detect(model_name, \"pars\") ~ \"parsimonious model\",\n                          TRUE ~ \"other\"),\n         family = case_when(str_detect(model_name, \"con\") ~ \"conservative\",\n                            str_detect(model_name, \"mai\") ~ \"mainstream\",\n                            TRUE ~ \"other\")) %&gt;%\n  mutate(d.cAIC_absolute = cAIC - min(cAIC)) %&gt;% \n  group_by(family, type) %&gt;%\n  # add delta value per group\n  mutate(d.cAIC_group = cAIC - min(cAIC),\n         d.RMSE_group = RMSE - min(RMSE)) %&gt;% \n  ungroup()\n\n# extract coefficients and p-values\ntidy &lt;- models %&gt;% select(tidy) %&gt;% unnest(tidy)\n\n# extract fitted, fixed and residuals\naugment &lt;- models %&gt;% select(augment) %&gt;% unnest(augment)\n\n# extract standard deviation of random effects\nstd_random &lt;- models %&gt;% select(model_name, std_random) %&gt;% unnest(std_random) %&gt;% pivot_wider(names_from = PARAMETER, values_from = VALUE)\n\nres_random &lt;- models %&gt;% select(model_name, res_random) %&gt;% mutate(res_random = as.numeric(res_random))",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Larix decidua</span>"
    ]
  },
  {
    "objectID": "5_results_PA_leaf_unfolding.html",
    "href": "5_results_PA_leaf_unfolding.html",
    "title": "4  Picea abies",
    "section": "",
    "text": "4.1 Effect shape of temperature\nTable 4.1: Comparison of model performance of linear and polynomial temperature parameters with cAIC and RMSE.\nTable 4.2: Comparison of parameters across models with estimate, standard error, t-value and p-value",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Picea abies</span>"
    ]
  },
  {
    "objectID": "5_results_PA_leaf_unfolding.html#effect-shape-of-temperature-with-chilling",
    "href": "5_results_PA_leaf_unfolding.html#effect-shape-of-temperature-with-chilling",
    "title": "4  Picea abies",
    "section": "4.2 Effect shape of temperature with chilling",
    "text": "4.2 Effect shape of temperature with chilling\n\n\n\n\nTable 4.3: Comparison of model performance of linear and non-linear growing degree days in combination with chilling degree days.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 4.4: Comparison of siginificance of various growing and chilling degree day combinations.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Picea abies</span>"
    ]
  },
  {
    "objectID": "5_results_PA_leaf_unfolding.html#global-model-variations",
    "href": "5_results_PA_leaf_unfolding.html#global-model-variations",
    "title": "4  Picea abies",
    "section": "4.3 Global model variations",
    "text": "4.3 Global model variations\n\n\n\n\nTable 4.5: Number of equally or almost equally informative conservative model variations and maximum model weights (Δ cAIC &lt; 4 and &lt; 2).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 4.6: The three best model variations derived from the global model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 4.7: The three most parsimonious models derived from the global model.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Picea abies</span>"
    ]
  },
  {
    "objectID": "5_results_PA_leaf_unfolding.html#model-processing",
    "href": "5_results_PA_leaf_unfolding.html#model-processing",
    "title": "4  Picea abies",
    "section": "4.4 Model processing",
    "text": "4.4 Model processing\n\n\nShow the code\n# nest data set\nmanual_models_input &lt;- data %&gt;%\n  nest()\n\n# save to file for evaluation of manual models in the template\nsaveRDS(manual_models_input, paste0(path_output_data, \"/manual_models_\", species, \"_\", gsub (\" \", \"_\", phase), \".rds\"))\n\n# source manual models to be evaluated within template\nsource(paste0(location, \"/5_manual_\", species, \"_\", gsub (\" \", \"_\", phase), \".R\"), echo=TRUE, max.deparse.length = 5000)\n\n\n\n&gt; manual_models &lt;- manual_models_input %&gt;% mutate(final_con_int = map(data, \n+     safely(~lme(fixed = doy ~ poly(GDD_conservative, degree = 2) + \n+         poly(STAND_HEIGHT, degree = 2) + TREE_ELEVATION, random = ~1 | \n+         METEO_ID, data = ., method = \"ML\", correlation = autoregression_simple, \n+         na.action = na.omit))), ref_imp_con_int = map(data, safely(~lme(fixed = doy ~ \n+     poly(GDD_conservative, degree = 2), random = ~1 | METEO_ID, \n+     data = ., method = \"ML\", correlation = autoregression_simple, \n+     na.action = na.omit))), final_con_slo = map(data, safely(~lme(fixed = doy ~ \n+     poly(GDD_conservative, degree = 2) + poly(STAND_HEIGHT, degree = 2) + \n+         TREE_ELEVATION, random = ~1 + GDD_conservative | METEO_ID, \n+     data = ., method = \"ML\", correlation = autoregression_simple, \n+     na.action = na.omit, control = lmeControl(opt = \"nlminb\", \n+         maxIter = 100, msMaxIter = 100, niterEM = 30)))), ref_imp_con_slo = map(data, \n+     safely(~lme(fixed = doy ~ poly(GDD_conservative, degree = 2), \n+         random = ~1 + GDD_conservative | METEO_ID, data = ., \n+         method = \"ML\", correlation = autoregression_simple, na.action = na.omit))))\n\n\nShow the code\n# format manual models to fit the data frame structure\nmanual_models &lt;- manual_models %&gt;%\n  pivot_longer(cols = 2:ncol(.), names_to = \"model_name\", values_to = \"model\") %&gt;% \n  filter(map_lgl(model, ~ !is.null(.x$result))) %&gt;%\n  mutate(model = map(model, \"result\"))\n\n\n\n\nShow the code\n# function to extract coefficients with confidence intervals\nsafe_tidy &lt;- possibly(\n  ~ broom.mixed::tidy(.x, conf.int = TRUE) %&gt;% mutate(model_name = .y), \n  otherwise = NULL\n)\n\nmodels &lt;- bind_rows(manual_models, ref_imp_models, ref_true_models, temp_test_models, global_models, best_models, parsimonious_models\n                    ) %&gt;%\n  filter(!str_detect(model_name, exclude_type)) %&gt;% \n  mutate(tidy = map2(model, model_name, safe_tidy), # extract coefficients and p-values\n         augment = map2(model, model_name, ~{ # extract fitted values, residuals, fixed effects without data that is not contained in the respective model\n           terms &lt;- all.vars(formula(.x))[-1]  # Extract terms and remove response variable\n           broom.mixed::augment(.x) %&gt;%\n           select(all_of(terms), METEO_ID, year, SPECIES_SHORT, .fitted, .resid, .fixed) %&gt;%\n           mutate(model_name = .y)\n           }),\n         terms = map(model, ~all.vars(formula(.x))[-1]),\n         std_random = map(model, ~safely(~ {\n           intervals(.x)$reStruct %&gt;%\n             unlist() %&gt;%\n             as.data.frame() %&gt;%\n             rename(VALUE = 1) %&gt;%\n             rownames_to_column(\"PARAMETER\")})(.x)$result), # calculate and extract standard deviation of random effects\n         res_random = (res_random = map(model, ~.x$sigma)),\n         RMSE = map(model, ~sqrt(mean(.x$residuals^2))), # extract RMSE across populations\n         cAIC = map(model, ~fun_get_caic(.x)), # extract cAIC\n         logLik = map(model, ~fun_get_log(.x)) # extract logLik\n         ) %&gt;%\n  unnest(cAIC, logLik, RMSE) %&gt;% \n    mutate(coef = map(model, ~coef(.x)),\n           terms_count = map(model, ~length(fixef(.x))+1), # extract number of parameters and add 1 for the grouping variable (for more details see Pinheiro and Bates 2000, p. 8)\n           RMSE = as.numeric(RMSE),\n           delta_total_cAIC = cAIC - min(cAIC))\n\n\n\n\nShow the code\n# extract RMSE\nselection_parameters &lt;- models %&gt;% \n  select(-tidy, -augment, -data, -terms) %&gt;% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %&gt;% paste(collapse = \" \")) %&gt;% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %&gt;% paste(collapse = \" \")) %&gt;% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %&gt;% as.character()) %&gt;% # extract random effects\n  select(model_name, RMSE, cAIC, logLik, terms_count, calls, fixed_effects, random_effects) %&gt;%\n  unnest(RMSE, cAIC, logLik, terms_count) %&gt;%\n  # add family and type\n  mutate(type = case_when(str_detect(model_name, \"temp_test\") ~ \"effect shape\",\n                          str_detect(model_name, \"ref_true\") ~ \"traditional reference\",\n                          str_detect(model_name, \"ref_imp\") ~ \"refined reference\",\n                          str_detect(model_name, \"final\") ~ \"final model\",\n                          str_detect(model_name, \"best\") ~ \"best model\",\n                          str_detect(model_name, \"global\") ~ \"global model\",\n                          str_detect(model_name, \"pars\") ~ \"parsimonious model\",\n                          TRUE ~ \"other\"),\n         family = case_when(str_detect(model_name, \"con\") ~ \"conservative\",\n                            str_detect(model_name, \"mai\") ~ \"mainstream\",\n                            TRUE ~ \"other\")) %&gt;%\n  mutate(d.cAIC_absolute = cAIC - min(cAIC)) %&gt;% \n  group_by(family, type) %&gt;%\n  # add delta value per group\n  mutate(d.cAIC_group = cAIC - min(cAIC),\n         d.RMSE_group = RMSE - min(RMSE)) %&gt;% \n  ungroup()\n\n# extract coefficients and p-values\ntidy &lt;- models %&gt;% select(tidy) %&gt;% unnest(tidy)\n\n# extract fitted, fixed and residuals\naugment &lt;- models %&gt;% select(augment) %&gt;% unnest(augment)\n\n# extract standard deviation of random effects\nstd_random &lt;- models %&gt;% select(model_name, std_random) %&gt;% unnest(std_random) %&gt;% pivot_wider(names_from = PARAMETER, values_from = VALUE)\n\nres_random &lt;- models %&gt;% select(model_name, res_random) %&gt;% mutate(res_random = as.numeric(res_random))",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Picea abies</span>"
    ]
  },
  {
    "objectID": "5_results_TC_leaf_unfolding.html",
    "href": "5_results_TC_leaf_unfolding.html",
    "title": "5  Tilia cordata",
    "section": "",
    "text": "5.1 Effect shape of temperature\nTable 5.1: Comparison of model performance of linear and polynomial temperature parameters with cAIC and RMSE.\nTable 5.2: Comparison of parameters across models with estimate, standard error, t-value and p-value",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tilia cordata</span>"
    ]
  },
  {
    "objectID": "5_results_TC_leaf_unfolding.html#effect-shape-of-temperature-with-chilling",
    "href": "5_results_TC_leaf_unfolding.html#effect-shape-of-temperature-with-chilling",
    "title": "5  Tilia cordata",
    "section": "5.2 Effect shape of temperature with chilling",
    "text": "5.2 Effect shape of temperature with chilling\n\n\n\n\nTable 5.3: Comparison of model performance of linear and non-linear growing degree days in combination with chilling degree days.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 5.4: Comparison of siginificance of various growing and chilling degree day combinations.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tilia cordata</span>"
    ]
  },
  {
    "objectID": "5_results_TC_leaf_unfolding.html#global-model-variations",
    "href": "5_results_TC_leaf_unfolding.html#global-model-variations",
    "title": "5  Tilia cordata",
    "section": "5.3 Global model variations",
    "text": "5.3 Global model variations\n\n\n\n\nTable 5.5: Number of equally or almost equally informative conservative model variations and maximum model weights (Δ cAIC &lt; 4 and &lt; 2).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 5.6: The three best model variations derived from the global model.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 5.7: The three most parsimonious models derived from the global model.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tilia cordata</span>"
    ]
  },
  {
    "objectID": "5_results_TC_leaf_unfolding.html#model-processing",
    "href": "5_results_TC_leaf_unfolding.html#model-processing",
    "title": "5  Tilia cordata",
    "section": "5.4 Model processing",
    "text": "5.4 Model processing\n\n\nShow the code\n# nest data set\nmanual_models_input &lt;- data %&gt;%\n  nest()\n\n# save to file for evaluation of manual models in the template\nsaveRDS(manual_models_input, paste0(path_output_data, \"/manual_models_\", species, \"_\", gsub (\" \", \"_\", phase), \".rds\"))\n\n# source manual models to be evaluated within template\nsource(paste0(location, \"/5_manual_\", species, \"_\", gsub (\" \", \"_\", phase), \".R\"), echo=TRUE, max.deparse.length = 5000)\n\n\n\n&gt; manual_models &lt;- manual_models_input %&gt;% mutate(final_con_int = map(data, \n+     safely(~lme(fixed = doy ~ GDD_conservative + TREE_ELEVATION + \n+         DROUGHT, random = ~1 | METEO_ID, data = ., method = \"ML\", \n+         correlation = autoregression_simple, na.action = na.omit))), \n+     ref_imp_con_int = map(data, safely(~lme(fixed = doy ~ GDD_conservative * \n+         CDD_conservative, random = ~1 | METEO_ID, data = ., method = \"ML\", \n+         correlation = autoregression_simple, na.action = na.omit))), \n+     final_con_slo = map(data, safely(~lme(fixed = doy ~ GDD_conservative + \n+         TREE_ELEVATION + DROUGHT, random = ~1 + GDD_conservative | \n+         METEO_ID, data = ., method = \"ML\", correlation = autoregression_simple, \n+         na.action = na.omit, control = lmeControl(niterEM = 40)))), \n+     ref_imp_con_slo = map(data, safely(~lme(fixed = doy ~ GDD_conservative, \n+         random = ~1 + GDD_conservative | METEO_ID, data = ., \n+         method = \"ML\", correlation = autoregression_simple, na.action = na.omit))))\n\n\nShow the code\n# format manual models to fit the data frame structure\nmanual_models &lt;- manual_models %&gt;%\n  pivot_longer(cols = 2:ncol(.), names_to = \"model_name\", values_to = \"model\") %&gt;% \n  filter(map_lgl(model, ~ !is.null(.x$result))) %&gt;%\n  mutate(model = map(model, \"result\"))\n\n\n\n\nShow the code\n# function to extract coefficients with confidence intervals\nsafe_tidy &lt;- possibly(\n  ~ broom.mixed::tidy(.x, conf.int = TRUE) %&gt;% mutate(model_name = .y), \n  otherwise = NULL\n)\n\nmodels &lt;- bind_rows(manual_models, ref_imp_models, ref_true_models, temp_test_models, global_models, best_models, parsimonious_models\n                    ) %&gt;%\n  filter(!str_detect(model_name, exclude_type)) %&gt;% \n  mutate(tidy = map2(model, model_name, safe_tidy), # extract coefficients and p-values\n         augment = map2(model, model_name, ~{ # extract fitted values, residuals, fixed effects without data that is not contained in the respective model\n           terms &lt;- all.vars(formula(.x))[-1]  # Extract terms and remove response variable\n           broom.mixed::augment(.x) %&gt;%\n           select(all_of(terms), METEO_ID, year, SPECIES_SHORT, .fitted, .resid, .fixed) %&gt;%\n           mutate(model_name = .y)\n           }),\n         terms = map(model, ~all.vars(formula(.x))[-1]),\n         std_random = map(model, ~safely(~ {\n           intervals(.x)$reStruct %&gt;%\n             unlist() %&gt;%\n             as.data.frame() %&gt;%\n             rename(VALUE = 1) %&gt;%\n             rownames_to_column(\"PARAMETER\")})(.x)$result), # calculate and extract standard deviation of random effects\n         res_random = (res_random = map(model, ~.x$sigma)),\n         RMSE = map(model, ~sqrt(mean(.x$residuals^2))), # extract RMSE across populations\n         cAIC = map(model, ~fun_get_caic(.x)), # extract cAIC\n         logLik = map(model, ~fun_get_log(.x)) # extract logLik\n         ) %&gt;%\n  unnest(cAIC, logLik, RMSE) %&gt;% \n    mutate(coef = map(model, ~coef(.x)),\n           terms_count = map(model, ~length(fixef(.x))+1), # extract number of parameters and add 1 for the grouping variable (for more details see Pinheiro and Bates 2000, p. 8)\n           RMSE = as.numeric(RMSE),\n           delta_total_cAIC = cAIC - min(cAIC))\n\n\n\n\nShow the code\n# extract RMSE\nselection_parameters &lt;- models %&gt;% \n  select(-tidy, -augment, -data, -terms) %&gt;% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %&gt;% paste(collapse = \" \")) %&gt;% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %&gt;% paste(collapse = \" \")) %&gt;% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %&gt;% as.character()) %&gt;% # extract random effects\n  select(model_name, RMSE, cAIC, logLik, terms_count, calls, fixed_effects, random_effects) %&gt;%\n  unnest(RMSE, cAIC, logLik, terms_count) %&gt;%\n  # add family and type\n  mutate(type = case_when(str_detect(model_name, \"temp_test\") ~ \"effect shape\",\n                          str_detect(model_name, \"ref_true\") ~ \"traditional reference\",\n                          str_detect(model_name, \"ref_imp\") ~ \"refined reference\",\n                          str_detect(model_name, \"final\") ~ \"final model\",\n                          str_detect(model_name, \"best\") ~ \"best model\",\n                          str_detect(model_name, \"global\") ~ \"global model\",\n                          str_detect(model_name, \"pars\") ~ \"parsimonious model\",\n                          TRUE ~ \"other\"),\n         family = case_when(str_detect(model_name, \"con\") ~ \"conservative\",\n                            str_detect(model_name, \"mai\") ~ \"mainstream\",\n                            TRUE ~ \"other\")) %&gt;%\n  mutate(d.cAIC_absolute = cAIC - min(cAIC)) %&gt;% \n  group_by(family, type) %&gt;%\n  # add delta value per group\n  mutate(d.cAIC_group = cAIC - min(cAIC),\n         d.RMSE_group = RMSE - min(RMSE)) %&gt;% \n  ungroup()\n\n# extract coefficients and p-values\ntidy &lt;- models %&gt;% select(tidy) %&gt;% unnest(tidy)\n\n# extract fitted, fixed and residuals\naugment &lt;- models %&gt;% select(augment) %&gt;% unnest(augment)\n\n# extract standard deviation of random effects\nstd_random &lt;- models %&gt;% select(model_name, std_random) %&gt;% unnest(std_random) %&gt;% pivot_wider(names_from = PARAMETER, values_from = VALUE)\n\nres_random &lt;- models %&gt;% select(model_name, res_random) %&gt;% mutate(res_random = as.numeric(res_random))",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tilia cordata</span>"
    ]
  },
  {
    "objectID": "6_species_comparison_leaf_unfolding.html",
    "href": "6_species_comparison_leaf_unfolding.html",
    "title": "6  Species comparison",
    "section": "",
    "text": "6.1 Variable importance\nTable 6.1: Number of conservative model variations with delta cAIC &lt; 4 and &lt; 2.\nFigure 6.1: Relative variable importance (VI) in high-performing models of leaf unfolding. Shown are the VI of model variations with ΔcAIC &lt; 2 (cAIC = conditional Akaike Information Criterion) relative to the model with the lowest cAIC that contain GDD and ≤ 10 main effects and interactions. A VI of 1 signals high importance relative to other variables, while lower values suggest that a variable appeared in fewer models or models with lower Akaike weights. Variables with the prefix “poly” were modelled with a non-linear relationship to DOY (Methods). The colon (:) indicates an interaction between two variables. Blanks represent variables that were not present in any well-performing models.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Species comparison</span>"
    ]
  },
  {
    "objectID": "6_species_comparison_leaf_unfolding.html#model-selection",
    "href": "6_species_comparison_leaf_unfolding.html#model-selection",
    "title": "6  Species comparison",
    "section": "6.2 Model selection",
    "text": "6.2 Model selection\n\n\n\n\nTable 6.2: Delta cAIC of best conservative models per type across species.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable 6.3: Model formula of best conservative models per type across species.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Species comparison</span>"
    ]
  },
  {
    "objectID": "6_species_comparison_leaf_unfolding.html#model-prediction-accuracy",
    "href": "6_species_comparison_leaf_unfolding.html#model-prediction-accuracy",
    "title": "6  Species comparison",
    "section": "6.3 Model prediction accuracy",
    "text": "6.3 Model prediction accuracy\n\n\n\n\n\n\n\n\nFigure 6.2: Model prediction accuracy using refined temperature-only models (black) and best models (green) to predict leaf unfolding across populations. Across-population predictions are based solely on fixed effects, excluding random effects and thus representing a generalized prediction. The dashed lines indicate perfect prediction of leaf unfolding, and deviations from it reflect prediction error.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Species comparison</span>"
    ]
  },
  {
    "objectID": "6_species_comparison_leaf_unfolding.html#coefficients",
    "href": "6_species_comparison_leaf_unfolding.html#coefficients",
    "title": "6  Species comparison",
    "section": "6.4 Coefficients",
    "text": "6.4 Coefficients\n\n6.4.1 Reference models\nReference models with random slopes for warming and chilling never converged, even when warming was simplified to a linear term only. Models with a random slope for warming but not chilling converged only for Larix decidua and Tilia cordata, but not Picea abies and Fagus sylvatica. In general reference models for Fagus sylvatica had more conversion issues than reference models of other species.\n\n\n\n\n\n\n\n\nFigure 6.3: Coefficient estimate and standard error per term for all zero models.\n\n\n\n\n\n\n\n\n\nTable 6.4: Coefficient estimates, confidence limits of 95% confidence intervals (conf.low, conf.high), standard error (SE) of coefficient estimates and p-values of refined models. The terms sd Intercept and sd Residuals describe the standard deviation of the random intercept and the residuals.\n\n\n\n\n\n\n\n\n\n\n\n\n6.4.2 Best models\n\n\n\n\nTable 6.5: Coefficient estimates, confidence limits of 95% confidence intervals (conf.low, conf.high), standard error (SE) of coefficient estimates and p-values of best models. The terms sd Intercept and sd Residuals describe the standard deviation of the random intercept and the residuals. The reference levels for relief position and social situation are “upper slope” and “forest”, respectively.\n\n\n\n\n\n\n\n\n\n\n\n\n6.4.3 Parsimonious models\n\n\n\n\nTable 6.6: Coefficient estimates, confidence limits of 95% confidence intervals (conf.low, conf.high), standard error (SE) of coefficient estimates and p-values of most parsimonious models. The terms sd Intercept and sd Residuals describe the standard deviation of the random intercept and the residuals. The reference levels for relief position and social situation are “upper slope” and “forest”, respectively.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Species comparison</span>"
    ]
  },
  {
    "objectID": "6_species_comparison_leaf_unfolding.html#effects-of-variables",
    "href": "6_species_comparison_leaf_unfolding.html#effects-of-variables",
    "title": "6  Species comparison",
    "section": "6.5 Effects of variables",
    "text": "6.5 Effects of variables\n\n\n\n\n\n\n\n\nFigure 6.4: Estimated shift (d) between earliest and latest DOY across the observed range of each environmental variable, based on predictions adjusted to mean covariate values. For each species, colours are scaled so the darkest shade represents the strongest shift.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6.5: Species-specific environmental drivers beyond temperature shape the timing of leaf unfolding. Panels show the estimated effect of predictors present in species-specific best models, adjusted for the influence of other included covariates at their mean values. Shaded areas and error bars represent 95% confidence intervals.\n\n\n\n\n\n\n6.5.1 Effects of interactions\n\n\n\n\n\n\n\n\nFigure 6.6: Effect of the interaction between GDD and CDD at low, medium and high CDD in the best model of lime. Predictions are adjusted to mean covariate values, with 95% confidence intervals (grey).\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6.7: Effect of the interaction between AWC and CWB at low, medium and high AWC in the best model of spruce. Predictions are adjusted to mean covariate values. Shaded areas represent 95% confidence intervals.",
    "crumbs": [
      "Results",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Species comparison</span>"
    ]
  }
]